# Static
### Static локални променливи 
- намират се в паметта на глобалните/статичните променливи
- създават се в началото на програмата и се унищожават в края на програмата 
- инициализира се само веднъж - при първото влизане в даден блок и запазва стойността си след излизане от него 

```cpp
int increment() {
    static int value = 0;
    ++value;
    return value;
}

int main() {
    std::cout << increment() << std::endl; //1
    std::cout << increment() << std::endl; //2
    std::cout << increment() << std::endl; //3
}
```

### Static функции
- static функции са видими само в текущия .cpp файл.
- Помагат за капсулация и избягване на конфликти с имена.


### Static член-данни на клас
- не са обвързани с конкретен обект, а с целия клас
- съхраняват се в общата памет на класа, а не в обекта
- всички обекти от класа използва една и съща инстанция
- имат само едно копие, независимо от броя на обектите
- инициализират се извън класа

### Static член-функции на клас
- не са обвързани с конкретен обект, а с целия клас
- използват се за достъпване на статичните член-данни
- нямат this указател, защото не работят върху конкретен обект
- може да се извикат без създаване на обект

За да бъде по-ясно, когато ползваме static член-данни или static член-функции на един клас, ще ги достъпваме чрез името на класа. 

```cpp
class Counter {
private:
    static int count;
public:
    Counter() { ++count; }
    static int getCount() { return count; }
};

int Counter::count = 0;

int main() {
    Counter c1, c2, c3;
    std::cout << "Objects: " << Counter::getCount() << std::endl;
}
```
*Обектите НЕ съхраняват count в себе си. Всеки обект ползва единствена статична член-данна.*

# Сложност 

Сложността е функция по големината на входа. 

**“Сложност на алгоритъм”** е мярка за това **колко ресурси полза този алгоритъм.**

**Сложността по време** е мярка, която ни казва как нараства времето за изпълнение на даден алгоритъм, когато  големината на входа му клони към *безкрайност*.  
**Сложността по памет** е мярка, която ни казва как нараства паметта, която даден алгоритъм ползва, когато големината на входа му клони към *безкрайност*.  

 Нека разгледаме следния алгоритъм:
```cpp
unsigned algA(unsigned n)
{
    unsigned result = 0;
    for(unsigned i = 1; i <= n; i++)
    {
        result += i;
    }
    return result;
}
```
Този алгоритъм приема цяло число `n` и намира сумата на числата от 1 до `n`. Нараства ли броят на стъпките, които алгоритъмът изпълнява, с нарастване на входа? Отговорът е да - при вход 10 цикълът `for` ще се завърти 10 пъти. При вход 100 той ще се завърти 100 пъти.

Сега нека разгледаме друг алгоритъм, решаващ същата задача:
```cpp
unsigned algB(unsigned n)
{
    return n * (n + 1) / 2;
}
```
Формулата е добре позната (формула за аритметична прогресия). Нараства ли броят на стъпките, които алгоритъмът изпълнява, с нарастване на входа? Отговорът е не - при вход 10 и при вход 100 винаги ще имаме едно събиране, едно умножение и едно делене.


Когато разглеждаме сложността по време на алгоритми, разглеждаме *три* случая:  

 - Най-добър случай (**Best case**)  
 - Среден случай (**Average case**)  
 - Най-лош случай (**Worst case**)  



 
# Свързан списък 
Свързаният списък е линейна структура от данни, в която елементите не се пазят в последователна памет. Всеки от тях съдържа не само информацията, която бихме пазили в масив, ами и информация кой е следващият елемент в поредицата – указател към следващия, а ако няма следващ пазим nullptr.
Стандартно се представя чрез указател към първия му елемент. 
